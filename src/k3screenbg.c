#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <signal.h>
#include <shutils.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <curl/curl.h>
#include <json.h>
#include "../networkmap/networkmap.h"
#include "config.h"
#include <ctype.h>
#include <unistd.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define NMP_CACHE_FILE "/tmp/nmp_cache.js"
#define REFRESH_INTERVAL_MIN 60 * 60 * 1

static unsigned long long last_upload_wan = 0, last_dnload_wan = 0;
static int NUM_2G = 0, NUM_5G = 0;
static int swmode = 0;
static time_t last_time = 0;

typedef struct Node
{
	char mac[18];
	char ip[15];
	unsigned long up_data;
	unsigned long dn_data;
	unsigned long last_up_data;
	unsigned long last_dn_data;
	struct Node *pNext; //定义一个结构体指针，指向下一次个与当前节点数据类型相同的
} NODE;

NODE *nodeHead = NULL;
NODE *nodeEnd = NULL;

char deflogo[] = "";
char OnePlus[] = "A091A2,5C17CF,AC5FEA,9809CF,4C4FEE,4801C5,64A2F9,E44122,94652D,C0EEFB";
char Qihoo360[] = "783607,DC5360,E4BAD9,000556,143605,000360,D0FA1D,043604,001C08,000E60,B4EF1C,2C7360,002360,001360";
char Asus[] = "001A83,049226,1831BF,88D7F6,6045CB,9C5C8E,0015F2,90E6BA,002618,F46D04,00E018,000C6E,000EA6,001D60,54A050,10C37B,E03F49,04D4C4,B06EBF,38D547,14DAE9,0011D8,0018F3,001A92,F832E4,305A3A,D850E6,74D02B,C86000,00040F,A85E45,2CFDA1,AC9E17,001FC6,708BCD,3085A9,002215,E0CB4E,001731,F07959,7824AF,BCEE7B,50465D,FCC233,244BFE,0C9D92,107B44,704D7B,3497F6,2C56DC,00248C,002354,1C872C,001E8C,0013D4,20CF30,1CB72C,086266,40167E,0005FC,D45D64,04D9F5,40B076,4CEDFB,2C4D54,D017C2,00112F,001BFC,485B39,BCAEC5,10BF48,14DDA9,382C4A,AC220B,60A44C,08606E,5404A6";
char Coolpad[] = "54DC1D,EC5A86,D03742,00166D,3C9157,18DC56";
char Dell[] = "98E743,C8F750,6C2B59,DCF401,4CD98F,CCC5E5,54BF64,001530,E0D848,D481D7,9840BB,801844,989096,847BEB,001AA0,0019B9,00B0D0,00C04F,74867A,180373,14FEB5,782BCB,001C23,A4BADB,002564,A41F72,00123F,000BDB,204747,D0431E,185A58,E454E8,8C04BA,F0D4E2,E4434B,D067E5,28F10E,F48E38,0026B9,64006A,001E4F,5C260A,7845C4,C81F66,0015C5,001422,109836,F8DB88,90B11C,0016F0,A4BB6D,2CEA7F,F40270,A89969,544810,8CEC4B,000097,8CCF09,20040F,E4F004,A44CC8,B82A72,001D09,0023AE,BC305B,B8CA3A,ECF4BB,D4BED9,000D56,549F35,842BBC,848F69,0025BD,3448ED,70B5E8,B8CB29,004E01,5CF9DD,886FD4,3C2C30,106530,000144,08001B,D89EF3,D09466,405CFD,509A4C,107D1A,14B31F,18DBF2,1866DA,B4E10F,002219,0024E8,B083FE,3417EB,F8BC12,18A99B,001372,001143,4C7625,44A842,F01FAF,00188B,000874,F8CAB8,28C825,D8D090,684F64,E4B97A,B88584,588A5A,001248,006048,7CC95A,484D7E,149ECF,141877,1C4024,18FB7B,F8B156,00065B,842B2B,F04DA2,E0DB55,000F1F,24B6FD,74E6E2,34E6D7,001EC9,002170,00219B,B8AC6F,D4AE52,246E96,1C721D,0C29EF,78AC44,C03EBA";
char Haier[] = "04E229,00258D,C8D779,2C37C5,18A7F1,0007A8,04FA83,D058C0,B0A37E,BC2B6B,DC330D,BC8AE8";
char Hasee[] = "0022C0,54CDA7";
char Honor[] = "";
char HP[] = "004084,002561,001B3F,040E3C,002347,0024A8,C09134,0021F7,00193C,00A068,B439D6,0026F1,4C3909,001DB3,001C2E,E8D8D1,3822E2,001FFE,001D31,B05CDA,4CDD7D,0016B9,F06281,001F28,0068EB";
char HTC[] = "404E36,AC3743,902155,D8B377,2C8A72,F8DB7F,64A769,E899C4,BCCFCC,00EEBD,502E5C,980D2E,D4206D,002376,38E7D8,188796,B4CEF6,002524,D40B1A,800184,847A88,A0F450,A826D9,74F61C,807ABF,00092D,7C6193,90E7C4,04C23E,1CB094,000714,00016B";
char Huawei[] = "10327E,30FBB8,44D791,8446FE,D82918,D46BA6,CC0577,D462EA,54BAD6,24166D,940B19,70C7F2,88F56E,C8C2FA,CC64A6,F89A78,88F872,EC5623,18022D,48F8DB,64F81C,807D14,20283E,88108F,F4631F,A49B4F,342EB6,AC9232,8C6D77,14579F,B44326,74C14F,B0EB57,F898EF,58F987,A8F5AC,58BAD4,00BE3B,7CA177,242E02,A4933F,F00FEC,AC075F,104400,B0E17E,E4A7C5,F86EEE,786256,B05508,28A6DB,14A0F8,3C678C,407D0F,68CC6E,D8C771,80D4A5,04B0E7,446A2E,5001D9,487B6B,883FD3,18D276,48FD8E,AC6175,244427,5CA86A,042758,9CE374,DCD916,9C741A,E4A8B6,244C07,54511B,D4612E,745AAA,04FE8D,48AD08,4CFB45,009ACD,7CB15D,88CF98,38F889,D07AB5,B43052,80D09B,1C8E5C,904E2B,2008ED,0034FE,C85195,40CBA8,D46E5C,8853D4,04C06F,202BC1,54A51B,002568,781DBA,00259E,D46AA8,B8BC1B,582AF7,4C8BEF,FC48EF,707BE8,4C1FCC,D4B110,E468A3,3400A3,68A828,BC9C31,E4C2D1,845B12,D4F9A1,0022A1,F03F95,185644,9C69D1,D88ADC,10E953,E04007,7817BE,740AE1,B4A898,0CE4A0,BC1AE4,702F35,6C1632,2C1A01,7422BB,2CC546,0C839A,E0E0FC,94E7EA,94E4BA,347146,F4B78D,A416E7,B40931,68E209,A0DE0F,F487C5,3C306F,80E1BF,482CD0,DC7385,5455D5,105DDC,9408C7,903FEA,20AB48,CCD73C,C8CA63,9437F7,A0D807,2C780E,34B20A,B00875,847637,FC9435,E02481,5CE883,100177,44A191,4459E3,9835ED,084F0A,A8494D,44004D,18CF24,D89B3B,88403B,FC8743,04885F,C850CE,20DA22,20658E,183D5E,88CEFA,70D313,9C1D36,CCBBFE,E43493,342912,14D169,60F18A,10C172,EC8C9A,B48655,D0D783,501D93,3CCD5D,7C7668,C49F4C,0C704A,B4FBF9,506F77,0C41E9,3CE824,940E6B,5C546D,0C8FFF,54B121,101B54,A80C63,5CC307,28B448,BC3F8F,143004,5004B8,44C346,307496,708A09,F02FA7,18DED7,7C11CB,049FCA,50016B,A47174,F4CB52,B808D7,34A2A2,749D8F,F823B2,E0A3AC,BC7574,20A680,8828B3,DCEE06,14D11F,DC094C,1C6758,24BCF8,A4BA76,48DB50,001882,20F3A3,0C37DC,BC7670,24DBAC,1C1D67,2469A5,EC233D,78F5FD,5C7D5E,90671C,BC25E0,F4E3FB,D02DB3,E8CD2D,84A8E4,0C96BF,60E701,E8088B,643E8C,7C6097,CC53B5,60DE44,105172,08E84F,888603,04F938,AC853D,4846FB,E0247F,00464B,80FB06,6889C1,2CCF58,7CA23E,88A2D7,9C37F4,3C4711,A0DF15,18703B,D89E61,347E00,78B46A,6CEBB6,4CF55B,E83F67,3446EC,6C06D6,DC21E2,FC1BD1,582575,28DEE5,44C7FC,7885F4,F4A4D6,08F458,B8E3B1,980D51,00ADD5,285471,B88E82,DC333D,785773,AC6089,843E92,708CB6,50464A,C4A402,183CB7,A4BDC4,5C9157,3066D0,3CB233,C0FFA8,30A2C2,283334,ACB3B5,08318B,3C9D56,70FD45,446747,E419C1,E4FDA1,FCBCD1,7460FA,8CFD18,C40683,94D00D,1C20DB,D0C65B,24DA33,FCAB90,E0CC7A,F47960,4455B1,70192F,DC16B2,24FB65,0CB527,347916,D016B4,D0EFC1,485702,9C713A,2C97B1,F8C39E,1409DC,60DEF3,EC8914,B89436,58D759,804126,ACF970,74D21D,602E20,E472E2,044F4C,1C151F,DCC64B,043389,2C55D3,C81451,F0C850,C80CC8,0425C5,3CFA43,145F94,F09838,F04347,9CB2B2,A8C83A,483C0C,20F17C,346AC2,84AD58,58605F,C4473F,2400BA,24DF6A,7C7D3D,4482E5,E84DD0,0C45BA,B05B67,CCA223,786A89,14B968,5CF96A,50A72B,0CD6BD,00F81C,087A4C,ACE215,346BD3,70723C,ACE87B,F83DFF,285FDB,404D8E,4C5499,F49FF3,240995,84DBAC,94772B,D440F0,04021F,200BC7,F84ABF,78D752,104780,548998,70A8E3,F8E811,94049C,688F84,30D17E,E03676,EC388F,D03E5C,A4DCBE,D494E8,F8BF09,5CB43E,249EAB,AC8D34,246F8C,1C1386,BC2EF6,4455C4,14A32F,04D3B5,00BB1C,E884C6,642CAC,A82BCD,48DC2D,D005E4,30AAE4,2811EC,38EB47,10C3AB,147740,18D98F,189E2C,5471DD,884033,E0D462,909838,F82F65,0831A4,A8E978,942533,8C5EBD,2CA042,C083C9,9844CE,F09BB8,ECC01B,048C9A,EC3CBB,BCB0E7,5434EF,ACE342,9017C8,E00084,F41D6B,2841C6,B4F58E,243154,2C58E8,F063F9,7CC385,30A1FA,3412F9,BCE265,4CD1A1,88BFE4,340A98,646D6C,C4B8B4,80B575,A4BE2B,A87D12,4CD0CB,505DAC,B4CD27,DC729B,909497,0CC6CC,785860,E8ABF3,6CB749,989C57,E86819,3C7843,5C0979,E4FB5D,8C2505,5425EA,C894BB,10B1F8,38BC01,341E6B,886639,884477,149D09,707990,4CF95D,8421F1,005A13,2C9D1E,68A0F6,446EE5,34B354,50680A,FC3F7C,384C4F,900325,98E7F5,7C1CF1,78F557,E02861,D0D04B,480031,2CAB00,A8CA7B,A08D16,EC4D47,F4559C,80B686,10C61F,CC96A0,F80113,A49947,C8D15E,C07009,8038BC,C4072F,F48E92,00664B,9CC172,247F3C,581F28,ECCB30,F4DCF9,308730,241FA0,18C58A,7054F5,DCD2FC,9017AC,34CDBE,D8490B,9C28EF,F898B9,FCE33C,C4447D,30E98E,ACBD70,C0B5CD,4C5077,30FD65,B0735D,5C78F8,B827C5,78C5F8,048C16,B4B055,540DF9,006619,B0CCFE,E48326,447654,7CD9A0,F033E5,B4F18C,D0B45D,8836CF,A4C54E,D4BBE6,40B6E7,B04502,1C1FF1,14DE39,60AAEF,9016BA,D44649,D0F3F5,9400B0,2848E7,E4268B,E43EC6,38881E,684AAE,60D755,A8C252,A04147,1CAECB,044A6C,38FB14,F0E4A2,24A52C,7C942A,1CB796,3847BC,549209,745909,68A03E,B8C385,C8A776,A400E2,483FE9,143CC3,A8E544,1C7F2C,88BCC1,8C426D,1C599B,806933,DC9088,902BD2,40EEDD,AC751D,289E97,8C15C7,60FA9D,DC9914,304596,C0F4E6,F4BF80,E0191D,3C15FB,881196,E40EEE,0C2C54,047970,A057E3,BC3D85,2054FA,38378B,002EC7,488EEF,5C0339,84A9C4,A0086F,D06F82,A0F479,844765,C4FF1F,F87588,F44C7F,A0A33B,D0FF98,B0E5ED,C486E9,C0BFC0,A08CF8,14A51A,047503,9C7DA3,A4C64F,8C0D76,84BE52,849FB5,A4CAA0,C88D83,C81FBE,203DB2,48D539,D4A148,D065CA,8CEBC6,B08900,CCCC81,08C021,600810,48435A,C4F081,801382,94FE22,608334,E47E66,94DBDA,9C52F8,BC620E,74A528,E09796,ACCF85,00E0FC,6416F0,88E3AB,C40528,3CDFBD,509F27,80717A,5C4CA9,F4C714,286ED4,001E10,5439DF,283CE4,587F66,64A651,086361,8C34FD,0819A6,3CF808,486276,B41513,AC4E91,283152,74882A,4CB16C,04BD70,E435C8,E8BDD1,5CB395,30F335,74A063,F4E5F2,541310,8CE5EF,54F294,484C86,A01C8D,F4DEAF,60123C,F4A59D,E0F442,F0C42F,C0B47D,C467D1,C8C465,1C4363,8C5AC1,A85AE0,A4B61E,B46E08,8C683A,2864B0,04F169,5021EC,28E34E,94E9EE,F8AF05,90173F,607ECD,80CFA2,0094EC,74452D,F05501,1413FB,B0761B";
char Apple[] = "608B0E,88B291,C42AD0,CCD281,1040F3,586B14,BCB863,44E66E,C0E862,F40616,E4B2FB,4C569D,38539C,402619,6CE85C,F83880,1094BB,F86FC1,28FF3C,F099B6,88E9FE,38892C,749EAF,94BF2D,40CBC0,C4618B,08E689,DC56E7,5433CB,3408BC,1C36BB,3C2EFF,24F677,B0CA68,C83C85,B8634D,A4E975,3035AD,844167,9800C6,AC1F74,A85C2C,00DB70,245BA7,70F087,B0702D,6C19C0,2C3361,ECADB8,9801A7,24F094,086D41,E0C767,80ED2C,AC61EA,38B54D,1C5CF2,28ED6A,A4D18C,241EEB,CC25EF,28CFE9,00A040,3CD0F8,680927,6CC26B,44D884,002608,0026B0,0026BB,D49A20,F81EDF,C82A14,3C0754,A4B197,F0B479,1093E9,442A60,A4D1D2,28CFDA,003065,001451,001E52,0021E9,CC08E0,045453,F4F951,C06394,18AF8F,C8B5B7,90B21F,30F7C5,40B395,44FB42,E88D28,949426,207D74,F4F15A,C86F1D,3090AB,8C2DAA,848506,98FE94,D8004D,64200C,C8334B,64E682,B8E856,D89695,1499E2,B418D1,9C207B,B065BD,542696,64A3CB,903C92,D81D72,341298,70E72C,70ECE4,68AE20,AC87A3,D8BB2C,D04F7E,2078F0,E0ACCB,A0999B,24240E,F0DBF8,48746E,54AE27,FCE998,0CBC9F,34363B,D0A637,789F70,9CF387,A85B78,C8F650,A88E24,CC20E8,70480F,F0B0E7,0469F8,4070F5,B035B5,800C67,90812A,B87BC5,102959,E47684,F05CD5,70EA5A,B440A4,48B8A3,F4DBE3,E8854B,E02B96,28EC95,F887F1,305714,C8B1CD,1460CB,B8F12A,804A14,703C69,14C213,A4D931,BCFED9,808223,BCE143,647033,846878,C8D083,6030D4,F895EA,18F1D8,30D9D9,D0817A,98CA33,68AB1E,70EF00,0C1539,D88F76,409C28,58E28F,787B8A,503237,B0481A,B49CDF,48BF6B,9C84BF,00B362,E4E4AB,60334B,FCD848,A860B6,C4B301,E05F45,483B38,1C9148,30636B,A4F1E8,440010,0056CD,00CDFE,E498D6,F431C3,64A5C3,002332,00236C,0023DF,002500,0025BC,0019E3,001B63,001EC2,001FF3,0010FA,0050E4,000D93,7CFADF,78A3E4,148FC6,286AB8,28E02C,E0B9BA,00C610,B8F6B1,8CFABA,7CD1C3,F0DCE2,24AB81,E0F847,28E7CF,E4CE8F,A82066,BC52B7,5C5948,C8BCC8,E8040B,145A05,1CABA7,C0847A,34159E,58B035,DC86D8,90B931,D0E140,24A2E1,80EA96,600308,04F13E,98F0AB,7831C1,783A84,5C8D4E,8863DF,881FA1,C8E0EB,98B8E3,885395,786C1C,4C8D79,1CE62B,0C3021,0C3E9F,FCFC48,9C293F,087402,94F6A3,98E0D9,CC29F5,285AEB,F02475,2C1F23,549F13,F0DBE2,748114,18F643,A45E60,A01828,D0034B,10417F,A8667F,D02598,80BE05,24A074,84788B,587F57,006D52,B844D9,14876A,E0B55F,F8FFC2,E0EB40,3CBF60,AC15F4,88A479,047295,D446E1,78D162,08F8BC,90A25B,7CAB60,44C65D,187EB9,20E874,D03FAA,A8913D,640BD7,0C3B50,507AC5,4C6BE8,8C861E,542B8D,4418FD,005B94,E0897E,64C753,38F9D3,FC183C,90E17B,D81C79,58E6BA,9CE65E,C49880,E0338E,08F69C,50A67F,D461DA,F01898,881908,5C0947,14205E,B841A4,D4909C,E4E0A6,80B03D,E49ADC,ACE4B5,D0D2B0,8C8590,6C96CF,78886D,20EE28,B4F61C,08F4AB,D4DCCD,484BAA,DCA904,6CAB31,4C74BF,989E63,886B6E,5082D5,64B0A6,7C04D0,84FCAC,DC0C5C,70700D,186590,F86214,784F43,404D7F,9C8BA0,CC088D,609AC1,748D08,10DDB1,C01ADA,68FB7E,84A134,0C5101,2CF0A2,B44BD2,DC415F,F45C89,20768F,E8B2AC,E49A79,38CADA,34AB37,18AF61,5CF938,6C72E7,741BB2,CC4463,60FEC5,E425E7,BC926B,101C0C,080007,40D32D,C42C03,9027E4,109ADD,581FAA,88C663,001F5B,002436,00254B,0016CB,0017F2,7C6D62,20C9D0,68967B,84FCFE,E48B7F,008865,BC3BAF,3CE072,38484C,A46706,8C5877,7CF05F,804971,6C3E6D,BC6778,D8D1CB,A8FAD8,B817C2,7C11BE,283737,50EAD6,98D6BB,189EFC,ACCF5C,80006E,848E0C,3C15C2,6C709F,C0F2FB,24E314,80E650,90FD61,087045,A88808,A4C361,2CF0EE,5C97F3,D4F46F,6476BA,34E2FD,04489A,F0F61C,8C2937,B09FBA,0C4DE9,E0F5C6,A0EDCD,5CF5DA,18EE69,649ABE,F099BF,94E96A,AC293A,9CFC01,9C35EB,48437C,34A395,787E61,60F81D,38C986,D03311,507A55,209BCD,F0A35A,608373,84AD8D,74428B,2877F1,88A9B7,ECCED7,AC9085,B89047,909C4A,908C43,3C7D0A,14C88B,EC2651,183EEF,607EC9,1855E3,E450EB,886440,6070C0,F0C371,941625,34A8EB,A483E7,F4AFE7,AC88FD,DC080F,F8E94E,EC2CE2,40BC60,E83617,9C648B,344262,14D00D,645AED,C0B658,48A91C,50BC96,FC2A9C,A056F3,549963,90DD5D,C48466,347C25,CC2DB7,E42B34,3C2EF9,A04EA7,F0989D,B019C6,3866F0,703EAC,9810E8,C0D012,BCA920,48A195,F80377,DCA4CA,8C8FE9,2C200B,8866A5,001CB3,F07960,A0D795,B8FF61,90C1C6,70A2B3,F40F24,4C57CA,48E9F1,1C9E46,C0CCF8,9C4FDA,8489AD,68DBCA,086698,BC5436,044BED,6C8DC1,0CD746,60A37D,9060F1,B8782E,000502,000A95,00264A,041E64,001124,002241,7CC537,78CA39,18E7F4,70CD60,8C7B9D,D89E3F,B8C75D,0C74C2,403004,842999,74E2F5,E0C97A,68A86D,7CC3A1,7073CB,90840D,E80688,EC852F,00F4B9,5C95AE,9803D8,60C547,685B35,2CB43A,689C70,380F4A,3010E4,A886DD,444C0C,B4F0AB,80929F,9C04EB,5C969D,609217,84B153,E06678,48D705,041552,CC785F,88CB87,F0C1F1,843835,8C006D,A8968A,F41BA1,60D9C7,3CAB8E,F82793,907240,908D6C,B8098A,4C7C5F,68644B,C81EE7,A43135,68D93C,00F76F,C88550,7014A6,985AEB,78D75F,E0B52D,6C94F8,C0CECD,C869CD,A4B805,5CADCF,BC6C21,544E90,ACBC32,7CA1AE,3C22FB,940C98,E8FBE9,38EC0D,E490FD,D06544,84AB1A,D8DC40,805FC5,3C4DBE,48262C,147DDA,C4910C,206980,74E1B6,F40E01,1495CE,50DE06,CC660A,FC1D43,B8B2F8,98460A,B85D0A,7C9A1D,103025,5462E2,149D99,C09AD0,94B01F,94F6D6,F82D7C,18810E,608C4A,74B587,FCB6D8,241B7A,8CFE57,C0A600,000393,1C1AC0,40831D,DCD3A2,5C1DD9,88AE07,68FEF7,68EF43,D02B20,2C61F6,D4A33D,F0766F,4098AD,6C4D73,7867D7,B8C111,9CE33F,A8BE27,C0A53E,D4619D,14BD61,7C5049,58404E,D0C5F3,BC9FEF,20AB37,60F445,88E87F,9CF48E,5CF7E6,B853AC,203CAE,A03BE3,4C3275,D83062,B88D12,8C8EF2,90B0ED,04D3CF,B48B19,BCEC5D,28A02B,3871DE,7081EB,606944,0452F3,60FB42,64B9E8,001D4F,002312,D8A25E,000A27,183451,0C771A,286ABA,4CB199,C09F42,D023DB,70DEE2,F0CBA1,182032,403CFC,4860BC,3451C9,406C8F,5855CA,DC2B61,40A6D9,60FACD,003EE1,FC253F,04F7E4,34C059,F0D1A9,705681,14109F,040CCE,54EAA8,28E14C,E4C63D,54E43A,04DB56,AC3C0B,701124,042665,EC3586,78FD94,2CBE08,E8802E,006171,8C7C92,B03495,F437B7,AC7F3E,280B5C,ACFDEC,DC9B9C,54724F,D8CF9C,7C6DF8,04E536,A8BBCF,6C4008,40331A,CCC760,BC4CC4,DC3714,20A2E4,28F076,7C0191,80D605,DC2B2A,082CB6,F84E73,F07807,3CCD36,444ADB,309048,BC0963,D84C90,24D0DF,6C4A85,28F033,E87F95,88C08B,4C7CD9";
char Lenovo[] = "2446C8,10C595,601D91,D4C94B,A41194,DCBFE9,A89675,F0D7AA,B07994,A470D6,E02CB2,E89120,74042B,4480EB,6099D1,C8DDC9,08AA55,8CF112,90735A,C08C71,BCFFEB,88B4A6,F4F524,EC8892,E0757D,34BB26,806C1B,A03299,1C56FE,F8CFC5,98FFD0,503CC4,149FE8,00061B,F81F32,CC0DF2,D463C6,CC61E5,88797E,408805,F8E079,CCC3EA,40786A,24DA9B,E4907E,60D9A0,207693,CC07E4,6C5F1C,005907,D4223F,08CC27,04D395,BC98DF,809621,0CCB85,3880DF,8058F8,68C44D,E09861,60BEB5,F8F1B6,F4F1E1,9CD917,9068C3,A48CDB,AC3870,80CF41,C8C750,58D9C3,304B07,D07714,D00401,141AA3,1430C6,84100D,5C5188,1436C6,88708C,70720D,EC89F5,D87157,0012FE";
char LeEco[] = "40270B,B4EFFA,28FECD,C825E1,847303";
char LG[] = "201742,CC8826,ACF6F7,2C2BF9,64C2DE,A49426,0057C1,785DC8,388C50,A06FAA,DC0B34,10F96F,C4438F,A09169,9893CC,3CCD93,2021A5,6CD68A,2C54CF,485929,58A2B5,002483,001FE3,50A9DE,C4366C,0CF019,1C08C1,2CE871,3CE624,0876FF,2C3F3E,0025E6,0023DD,001F9F,0018F6,0018E3,00147F,0013A0,001106,00E095,00200E,08007E,7CF31B,A04F85,58FDB1,7440BE,7C1C4E,48605F,044EAF,B4F7A1,88365F,041B6D,30766F,A8922C,F80CF3,C49A02,001F6B,0026E2,5C70A3,B08991,002644,0023EC,000E50,000C57,0005C9,0090D0,C8F319,64956C,60AB14,3830F9,003DE8,000261,00E091,B4F1DA,B4E62A,B81DAA,5CAF06,D013FD,6CD032,3CBDD8,344DF7,583F54,64899A,F8A9D0,CCFA00,74A722,F01C13,A816B2,64BC0C,AC0D1B,0034DA,30A9DE,F0182B,FC0012,188ED5,F0ED1E,0024FA,002390,0022EE,001480,00130F,000B29,0006D0,00305A,0050A9,0050CE,00103F,002021,A48CC0,0051ED,08D46A,203DBD,10F1F2,F4D7B2,70AF24,805A04,4C26E7,2C598A,CC2D8C,98D6F7,700514,E892A4,10683F,40B0FA,0025E5,0021FB,34FCEF,BCF5AC,0C4885,0022A9,C80210,A039F7,14C913,E8F2E2,EC2E4E,B061C7,5C17D3,906DC8,001EB2,001DD7,001D68,0019A1,001256,000CB5,00C00C,44CB8B,402F86,30FCEB,90272B,98B8BA,0040BC,A823FE,64209F,30B4B8,A8B86E,D84FB8,00AA70,F895C7,001E75,001C62,505527,88C9D0,C041F6,8C3AE3,60E3AC,88074B,78F882,C808E9,B0989F,944444,B40EDC,64995D,E85B5B,8C541D,A03A75,002417,0019E9,009002,080041";
char Meitu[] = "C09A71";
char Meizu[] = "5CCD7C,38BC1A,683E34,90F052";
char OPPO[] = "2479F3,C4E39F,D81EDD,C02E25,58C6F0,2CA9F0,B4CB57,18D717,E4C483,084ACF,D4503F,38295A,E44790,C8F230,8C0EE3,B0AA36,A09347,E8BBA8,B8C9B5,F06728,B0B5C3,F4D620,44AEAB,A4F05E,846FCE,5029F5,1CC3EB,7836CC,EC51BC,F079E8,3CF591,602101,ECF342,4C1A3D,CC2D83,DC6DCD,BC3AEA,A43D78,0022DE,FCA5D0,6CD71F,885A06,2C5D34,D467D3,A41232,9C0CDF,14C697,7C6B9C,4466FC,503CEA,F06D78,1CDDEA,88D50C,1C48CE,D436DB,6C5C14,1C77F6,20826A,5C666C,C4E1A1,70DDA8,4C6F9C,4883B4,D41A3F,986F60,C09F05,440444,88B8D0,18D0C5,9CF531,14472D,1C0219,489507,B8C74A,1C427D,587A6A,DC5583,94D029,308454,4C189A,B83765,EC01EE,A81B5A,2C5BB8,A4C939,9C5F5A,B4A5AC,C4FE5B,2064CB";
char Phicomm[] = "2C15E1,2CB21A,98BB99,D8C8E9,747D24,FC7C02,CC81DA,68DB54,006B8E,F0EBD0,8CAB8E,D842AC";
char Samsung[] = "D0D003,8CB84A,7C8956,88299C,8C79F5,D003DF,FC039F,A4D990,3C576C,08C5E1,E4B021,C048E6,CC6EA4,A816D0,A46CF1,08AED6,9CE063,D03169,149F3C,7C6456,389AF6,E0AA96,507705,C8D7B0,9097F3,7C1C68,C087EB,3096FB,4827EA,7C787E,28395E,8CF5A3,D47AE2,D8E0E1,F83F51,60A4D0,008701,5C9960,101DC0,68EBAE,444E1A,78471D,A07591,0CDFA4,002637,002119,F4D9FB,3C6200,5CA39D,90187C,50CCF8,50B7C3,1C5A3E,A02195,E47CF9,4844F7,001377,002454,E81132,C06599,BC79AD,4C3C16,0073E0,0017D5,001E7D,001DF6,F008F1,58C38B,00E3B2,301966,F0E77E,94350A,001D25,343111,08FD0E,041BBA,889B39,E432CB,BC8CCD,D022BE,EC9BF3,F409D8,10D542,A0821F,F06BCA,AC3613,4849C7,849866,9476B7,4C6641,B8BBAF,60C5AD,CCB11A,E4FAED,288335,DCCF96,A80600,F05A09,503275,08FC88,24F5AA,988389,84A466,C4576E,508569,F8D0BD,78595E,0C1420,94B10A,3CBBFD,A48431,A0B4A5,E4F8EF,E8B4C8,D087E2,F05B7B,B047BF,7C0BC6,205531,5440AD,804E81,FC8F90,9CD35B,A89FBA,30D587,D059E4,14A364,002538,0C2FB0,70CE8C,F4FEFB,B41A1D,30AB6A,60684E,8020FD,B4CE40,04BDBF,BC7ABF,54219D,00FA21,7C2302,D49DC0,489DD1,B06FE0,60D0A9,007C2D,007204,BCA58B,80CEB9,00C3F4,FC643A,A8515B,88BD45,54FCF0,306A85,4CDD31,D0B128,BC5451,2C4053,ACAFB9,503DA1,3C0518,900628,38AA3C,EC107B,1C232C,0021D1,001FCC,60A10A,8C71F8,CC051B,8C7712,9463D1,0021D2,5C497D,7825AD,ECE09B,78D6F0,BC20A4,08D42B,789ED0,B0C4E7,A00798,001FCD,38ECE4,945103,002490,0023D7,549B12,FCA13E,24C696,94D771,E84E84,001632,E4E0C5,C81479,1CAF05,0016DB,001EE2,20D5BF,5CE8EB,C0BDD1,B479A7,B0DF3A,805719,34BE00,78521A,205EF7,141F78,B47443,F877B8,182195,44783E,14BB6E,28CC01,6CF373,9C3AAF,781FDB,4CA56D,B86CE8,0CB319,183F47,B46293,50A4C8,1867B0,6C8336,ACEE9E,B857D8,AC5A14,08ECA9,7840E4,E09971,10D38A,6077E2,FC1910,3CA10D,646CB2,680571,14B484,000918,00E064,749EF5,68BFC4,04B1A1,CC464E,5050A4,8086D9,386A77,5CC1D7,9880EE,90EEC7,1029AB,184ECB,A027B6,103917,4CC95E,8CE5C0,F08A76,ECAA25,687D6B,485169,A8DB03,A8346A,3C20F6,7C38AD,F47DEF,7C8BB5,D07FA0,00B5D0,1496E5,8CB0E9,108EE0,FCA621,A8CAB9,641CAE,641CB0,24181D,2802D8,48C796,F4C248,F47190,54B802,448F17,DC44B6,1007B6,342D0D,54BD79,30074D,947BE7,5092B9,DC74A8,C4AE12,D4AE05,F0EE10,20DBAB,E8E5D6,C87E75,00265F,00233A,0007AB,382DD1,FC1F19,840B2D,206432,B407F9,00166C,181EB0,E8039A,30CDA7,001247,001599,0012FB,D0667B,B85E7B,E492FB,6CB7F4,2C4401,B8D9CE,1C66AA,3C8BFE,D4E8B2,1489FD,BC851F,0015B9,002491,002339,5001BB,54880E,F025B7,BC72B1,78F7BE,684898,3423BA,400E85,C8BA94,843838,5C3C27,888322,E89309,78C3E9,8C1ABF,30CBF8,A0CBFD,E45D75,D0FCCC,98398E,C09727,202D07,08373D,C488E5,FCC734,8425DB,B0EC71,E458B8,088C2C,64B853,389496,5056BF,90F1AA,1077B1,A49A58,08EE8B,74458A,38D40B,E83A12,80656D,FCF136,18895B,78BDBC,7CF90E,50F0D3,84119E,244B03,244B81,60AF6D,B85A73,981DFA,C44202,5C2E59,103047,F884F2,E0CBEE,FC0012,0023C2,000DE5,8031F0,E0D083,D80B9A,88A303,FCDE90,1854CF,807B3E,F8F1E6,701F3C,D48A39,E4F3C4,08BFA0,6C2F8A,1819D6,20326C,6489F1,E458E7,6CC7EC,C0BDC8,647BCE,A887B3,6C006B,24FCE5,70FD46,8C83E1,889F6F,68E7C2,58B10F,C819F7,3CDCBC,804E70,D4E6B7,5C865C,D80831,982D68,7C2EDD,3CF7A4,E47DBD,842519,24920E,FC4203,A01081,BC4760,04180F,2013E0,002566,DC7144,980C82,A00BBA,606BBD,00214C,0018AF,001EE1,00166B,0000F0,8CC8CD,A8F274,D487D8,184617,380A94,D0DFC7,D0C1B1,8018A7,F47B5E,70F927,C45006,88329B,1449E0,D02544,BC4486,20D390,9401C2,50FC9F,380B40,F0728C,34AA8B,24DBED,84B541,006F64,DC6672,F8E61A,9C2A83,A06090,BC765E,D85B2A,40163B,C83870,647791,9CE6E7,9C0298,28987B,54FA3E,0C8910,78ABBB,D8C4E9,BCD11F,F4428F,446D6C,00F46F,0C715D,2CAE2B,F40E22,C01173,BCE63F,7C9122,2827BF,8CBFA6,C8A823,B0C559,BC1485,083D88,608F5C,109266,745F00,DCDCE2,A0AC69,1089FB,A4307A,DC8983,5CCB99,90B144,6CDDBC,2468B0,0024E9,D85575,D411A3,04BA8D,B8BC5B,90633B,FCAAB6,782327,DCF756,CC2119,702AD5,74EB80,0CE0DC,D868C3,C493D9,A82BB9,705AAC,685ACF,0CA8A7,9C8C6E,00BF61,A407B6,087808,887598,C0174D,04D6AA,08152F,5C5181,608E08,B4BFF6,58C5CB,84C0EF,C0D3C0,948BC1,14568E,682737,2C0E3D,2CBABA,40D3AE,3816D1,D0176A,D48890,5492BE,000278,002399,0017C9,C4731E,5C0A5B,7CF854,001B98,001A8A,3C5A37,F49F54,34C3AC,44F459,00265D,CCF9E8,D857EF,18E2C2,9852B1,E440E2,103B59,D890E8,C462EA,14F42A,0808C2,CCFE3C,28BAB5,182666,30D6C9,CC07AB,002567,BCB1F3,1C62B8,B43A28,78A873,001C43,0023D6,E4121D,EC1F72,E8508B,F8042E,0821EF,34145F,845181,70288B,348A7B,78009E,ACC33A,54F201,1C3ADE,AC5F3E,509EA7,A88195,88ADD2,50F520,64B310,A4EBD3,5CF6DC,B8C68E,04FE31,4CBCA5,D831CF,188331,9C65B0,8455A5,A87C01,B0D09C,50C8E5,48137E,382DE8,C08997,380195,842E27,1432D1,1816C9,E0DB10,9000DB,B4EF39,183A2D,206E9C,6C2F2C,18227E,30C7AE,CC3A61,000DAE,C0DCDA,04B429,48794D,942DDC,245AB5,C0D2DD,AC1E92,3868A4,9CA513,445CE9,140152,98063C";
char Smartisan[] = "B40B44,34D712";
char Sony[] = "D4389C,001FA7,709E29,002345,6C0E0D,6C23B9,3017C8,0012EE,001620,001963,001FE4,205476,001A80,68764F,5453ED,F0BF97,0022A6,78C881,3C0771,BC60A7,A8E3EE,00248D,00041F,001E45,001CA4,001A75,78843C,0013A9,000AD9,000E07,94CE2C,FC0FE6,0023F1,C43ABE,307512,B4527E,38184C,2CCC44,387862,C863F1,001D0D,84C7EA,FCF152,9C5CF9,5CB524,90C115,D05162,18002D,280DFC,0024EF,0025E7,58170C,0016B8,080046,584822,848EDF,30A8DB,A0E453,544249,2C97ED,94DB56,3C01EF,6CB227,F8461C,AC9B0A,104FA8,0015C1,001DBA,0024BE,000FDE,0CFE45,E063E5,F8D0AC,2421AB,B8F934,8C6422,001B59,002298,40B837,1C7B21,4C21D0,000095,CC988B,702605,00219E,283F69,045D4B,D8D43C,0019C5,001315,8400D2,303926,00EB2D,B4527D,00D9D1,00014A,001EDC,001D28,001813,402BA1,4040A7,BC6E64,44746C,44D4E0,30F9ED";
char TCL[] = "408BF6,3C591E,0000DD,001C50,345180,C87EA1,88D039,4C14A3,6C5AB5,001DFB,000E1F,CCA12B,5CAD76,5C36B8,345ABA";
char ThinkPad[] = "";
char TongfangPC[] = "002278,74372F,002646,00163D";
char VIVO[] = "1802AE,0C20D3,08B3AF,DC31D1,E013B5,88F7BF,4CC00A,9CE82B,3CA616,F4B7B3,C4ABB2,1CDA27,6091F3,BC2F3D,9CA5C0,C46699,207454,F8E7A0,2CFFEE,087F98,FCBE7B,B40FB3,283166,70B7AA,946372,B80716,70D923,F470AB,3CB6B7,3CA348,E45AA2,609E64,001981,18E777,6CD94C,642C0F,309435,488764,5C1CB9,7047E9,90ADF7,70788B,0823B2,F01B6C,20311C,08FA79,808A8B,449EF9,EC7D11,386EA2,5419C8,9CFBD5,18E29F,886AB1,E0DDC0,28FAA0,ECDF3A,F42981,64B64A,D8A315,D4BBC8,90C54A,20F77C,3CA581,34E911,94147A,205D47,000A0E,DC1AC5,101212,FC1A11,10F681,0002D1,3C86D1,6C24A6,98C8B8,540E2D,708F47";
char Microsoft[] = "70BC10,F06E0B,F01DBC,38F23E,80C5E6,4886E8,EC59E7,2C2997,7CED8D,1C1ADF,B831B5,2816A8,38256B,E498D1,6C2779,B4E1C4,206274,D48F33,20A99B,3059B7,7C1E52,DCB4C4,6C2483,5CCA1A,607EDD,300D43,5882A8,485073,149A10,74E28C,102F6B,002248,987A14,845733,0017FA,9CAA1B,EC8350,2C5491,C49DED,5CBA37,BC8385,C83F26,6C8FB5,985FD3,A4516F,9C6C15,C0335E,D0929E,281878,00155D,00125A,000D3A,0003FF,6C5D3A,DC9840,3C8375,949AA9,4C0BBE,0CE725,B4AE2B,0C413E,8463D6,B84FD5,501AC5,6045BD,0025AE,001DD8,0050F2";
char XiaoMi[] = "A44519,D09C7A,50EC50,70BBE9,04CF8C,40313C,20A60C,8035C1,2047DA,7C49EB,38E60A,4C49E3,00EC0A,3CBD3E,286C07,28E31F,8C53C3,4C6371,D45EEC,88C397,F4308B,50D2F5,28167F,04C807,20F478,E0B655,E0DCFF,EC4118,C82832,48FDA3,A45046,E06267,082525,F460E2,9C2EA1,0CF346,80AD16,64CC2E,2082C0,7C1DD9,A086C6,9C99A0,584498,5CE50C,E85A8B,A44BD5,44237C,9078B2,BC7FA4,60AB67,7C035E,1801F1,7C03AB,D832E3,9487E0,50A009,508F4C,7811DC,38A4ED,742344,102AB3,185936,F8A45F,640980,E01F88,6490C1,9C28F7,5448E6,ECFA5C,C83DDC,2034FB,A89CED,703A51,04E598,482CA0,04D13A,0C9838,04B167,50642B,ACC1EE,B0E235,C46AB7,FC64BA,68DFDD,98FAE3,F0B429,64DDE9,2CD066,1CCCD6,582059,B4C4FC,7CD661,E446DA,8C5AF8,D8CE3A,E4DB6D,D86375,18F0E4,F4F5DB,ECD09F,34CE00,C40BCB,64B473,7451BA,7802F8,ACF7F3,D4970B,8CBEBE,14F65A,009EC8,0C1DAF,3480B3,F48B32,E0CCF8,98F621";
char ZTE[] = "086083,E01954,50AF4D,C8EAF8,709F2D,84139F,24D3F2,781D4A,B0ACD2,9C63ED,D4C1C8,88D274,049573,78C1A7,8CE117,688AF0,D058A8,D071C4,24C44A,FC2D5E,083FBC,002675,0019C6,84742A,9CD24B,C87B5B,D05BA8,D437D7,CC7B35,5422F8,901D27,8CE081,48282F,001AE7,6CD2BA,90FD73,F80DF0,9CE91C,347839,3CF652,80B07B,C85A9F,44FB5A,4413D0,C09FE1,DC7137,FC94CE,90869B,8C14B4,4CABFC,A44027,38E2DD,885DFB,288CB8,287B09,30D386,681AB2,004A77,74B57E,18686A,C864C7,749781,744AA4,00300A,601888,002512,344B50,FCC897,346987,98F428,143EBF,A8A668,208986,182012,9CA9E4,E47723,146080,2C26C5,4C09B4,001AEE,000947,041DC7,B00AD5,98006A,BC1695,DCDFD6,C0FD84,1C2704,5078B3,841C70,20E882,44FFBA,7C3953,38E1AA,B4DEDF,B0C19E,0C3747,18132D,4859A4,EC8A4C,F4E4AD,28FF3E,689FF0,64136C,90C7D8,10D0AB,384608,4CAC0A,B4B362,B075D5,D0154A,0026ED,002293,54BE53,94A7B7,1844E6,6CA75F,8C7967,D855A3,38D82F,E08E3C,8432EA,2C957F,F8DFA8,34E0CF,8CDC02,B0B194,9C2F4E,D8A8C8,E8A1F8,304240,DCF8B9,94BF80,AC00D0,24586E,247E51,E8B541,E4BD4B,8C68C8,EC8263,309935,0C72D9,9C6F52,601466,F8A34F,E07C13,F41F88,981333,A091C8,D476EA,08181A,001E73,0015EB,F4B8A7,300C23,44F436,78312B,344DEA,4C16F1,EC1D7F,84850A,A47E39,0C1262,986CF5,4CCBF5,78E8B6,F084C9,E0C3F3,F46DE2,7866AE,002447,001F07,00903F,5C3A3D,4C494F,C4741E,94E3EE,E47E9A,F4B5AA,E8ACAD,34DAB7,ECF0FE,E4CA12,D49E05,585FF6,386E88,E0383F,D47226,B41C30,847460,EC237B,48A74E,D0608C,702E22,540955,C4A366,6073BC,B805AB,789682,343759,74A78E,98F537,AC6462,90D8F3,3CDA2A,D87495,34DE34,30F31D,A0EC80,CC1AFA,6C8B2F,B49842,DC028E,001352,E447B3,D4B709,EC6CB5,C0B101";
char *logo[] = {deflogo, OnePlus, Qihoo360, Asus, Coolpad, Dell, Haier, Hasee, Honor, HP, HTC, Huawei, Apple, Lenovo, LeEco, LG, Meitu, Meizu, OPPO, Phicomm, Samsung, Smartisan, Sony, TCL, ThinkPad, TongfangPC, VIVO, Microsoft, XiaoMi, ZTE};

#ifdef RTCONFIG_BCM5301X_TRAFFIC_MONITOR
uint32_t traffic_wanlan(char *ifname, uint32_t *rx, uint32_t *tx);
#endif

void get_json_value(struct json_object *json, const char *key, char value[])
{
	if (json_object_is_type(json, json_type_object))
	{
		json_object_object_foreach(json, json_key, json_value)
		{
			if (strcmp(json_key, key) == 0)
			{
				strcpy(value, json_object_get_string(json_value));
				return;
			}
			get_json_value(json_value, key, value);
		}
	}
	else if (json_object_is_type(json, json_type_array))
	{
		struct json_object *tmp_obj = json_object_array_get_idx(json, 0);
		get_json_value(tmp_obj, key, value);
	}
}

size_t getcontentlengthfunc(void *ptr, size_t size, size_t nmemb, void *stream)
{
	int r;
	long len = 0;

	r = sscanf(ptr, "Content-Length: %ld\n", &len);
	if (r)
		*((long *)stream) = len;

	return size * nmemb;
}

size_t wirtefunc(void *ptr, size_t size, size_t nmemb, void *stream)
{
	return fwrite(ptr, size, nmemb, stream);
}

int curl_download_file(CURL *curlhandle, const char *url, const char *localpath, int timeout, int tries)
{
	FILE *fd = NULL;
	curl_off_t local_file_len = -1;
	long filesize = 0;

	CURLcode r = CURLE_GOT_NOTHING;
	struct stat file_info;
	int use_resume = 0;

	if (stat(localpath, &file_info) == 0)
	{
		local_file_len = file_info.st_size;
		use_resume = 1;
	}
	if ((fd = fopen(localpath, "ab+")) == NULL)
	{
		return -1;
	}

	curl_easy_setopt(curlhandle, CURLOPT_URL, url);
	curl_easy_setopt(curlhandle, CURLOPT_CONNECTTIMEOUT, timeout);
	curl_easy_setopt(curlhandle, CURLOPT_HEADERFUNCTION, getcontentlengthfunc);
	curl_easy_setopt(curlhandle, CURLOPT_HEADERDATA, &filesize);
	curl_easy_setopt(curlhandle, CURLOPT_RESUME_FROM_LARGE, use_resume ? local_file_len : 0);
	curl_easy_setopt(curlhandle, CURLOPT_SSL_VERIFYPEER, 0);
	curl_easy_setopt(curlhandle, CURLOPT_SSL_VERIFYHOST, 0);
	curl_easy_setopt(curlhandle, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1);
	curl_easy_setopt(curlhandle, CURLOPT_WRITEDATA, fd);
	curl_easy_setopt(curlhandle, CURLOPT_WRITEFUNCTION, wirtefunc);
	curl_easy_setopt(curlhandle, CURLOPT_NOPROGRESS, 1);
	curl_easy_setopt(curlhandle, CURLOPT_VERBOSE, 1);

	r = curl_easy_perform(curlhandle);
	fclose(fd);

	if (r == CURLE_OK)
	{
		return 1;
	}
	else
	{
		fprintf(stderr, "%s\n", curl_easy_strerror(r));
		return 0;
	}
}

NODE *FindNode(char mac[18])
{
	NODE *temp = nodeHead;
	while (temp)
	{
		if (!strcmp(mac, temp->mac))
		{
			return temp;
		}
		temp = temp->pNext;
	}
	return NULL; //没找到
}

void AppendNode(char mac[18], char ip[15], signed int up_data, signed int dn_data, signed int last_up_data, signed int last_dn_data)
{
	NODE *temp = NULL;

	if (temp = FindNode(mac))
	{
		//节点数据进行赋值
		strlcpy(temp->mac, mac, sizeof(temp->mac));
		if (ip)
			strlcpy(temp->ip, ip, sizeof(temp->ip));
		if (up_data)
			temp->up_data = up_data;
		if (dn_data)
			temp->dn_data = dn_data;
		if (last_up_data)
			temp->last_up_data = last_up_data;
		if (last_dn_data)
			temp->last_dn_data = last_dn_data;
		return;
	}

	//创建一个节点
	temp = (NODE *)malloc(sizeof(NODE)); //此处注意强制类型转换

	//节点数据进行赋值
	strlcpy(temp->mac, mac, sizeof(temp->mac));
	strlcpy(temp->ip, ip ? ip : "", sizeof(temp->ip));
	temp->up_data = up_data ? up_data : 0;
	temp->dn_data = dn_data ? dn_data : 0;
	temp->last_up_data = last_up_data ? last_up_data : 0;
	temp->last_dn_data = last_dn_data ? last_dn_data : 0;
	temp->pNext = NULL;

	//连接分两种情况1.一个节点都没有2.已经有节点了，添加到尾巴上
	if (NULL == nodeHead)
	{
		nodeHead = temp;
	}
	else
	{
		nodeEnd->pNext = temp;
	}
	nodeEnd = temp; //尾结点应该始终指向最后一个
}

void FreeNodeList()
{
	NODE *temp = nodeHead; //定义一个临时变量来指向头
	while (temp)
	{
		NODE *pt = temp;
		temp = temp->pNext; //temp指向下一个的地址 即实现++操作
		free(pt);			//释放当前
	}
	nodeHead = NULL;
	nodeEnd = NULL;
}

static int get_custom_clientlist_info(struct json_object *json_object_ptr)
{
	int have_data = 0;
	char *buf, *g, *p;
	char *name, *mac, *group, *type, *callback, *keeparp;
	g = buf = strdup(nvram_safe_get("custom_clientlist"));
	struct json_object *client_attr = NULL;

	if (strcmp(buf, "") != 0)
	{
		while (buf)
		{
			if ((p = strsep(&g, "<")) == NULL)
				break;

			if ((vstrsep(p, ">", &name, &mac, &group, &type, &callback, &keeparp)) != 6)
				continue;

			client_attr = json_object_new_object();
			json_object_object_add(client_attr, "name", json_object_new_string(name));
			json_object_object_add(client_attr, "group", json_object_new_string(group));
			json_object_object_add(client_attr, "type", json_object_new_int(atoi(type)));
			json_object_object_add(client_attr, "callback", json_object_new_string(callback));
			json_object_object_add(client_attr, "keeparp", json_object_new_string(keeparp));
			json_object_object_add(json_object_ptr, mac, client_attr);

			have_data = 1;
		}
	}

	free(buf);

	return have_data;
}

static int get_client_detail_info(struct json_object *clients, key_t shmkey)
{
	int shm_client_info_id;
	int lock;
	int i, j, len;
	void *shared_client_info = (void *)0;
	char ipaddr[15], mac_buf[18], dev_name[32], wireless[8];
	P_CLIENT_DETAIL_INFO_TABLE p_client_info_tab;
	char devname[LINE_SIZE], character;

	struct json_object *client = NULL;
	struct json_object *customList = NULL, *custom_attr_get = NULL;
	struct json_object *custom_attr_get_name = NULL;
	int customList_status = 0;

	//get custom_clientlist
	customList = json_object_new_object();
	customList_status = get_custom_clientlist_info(customList);

#ifdef RTCONFIG_DISABLE_NETWORKMAP
	if (nvram_match("networkmap_enable", "0"))
		return 0;
#endif

	lock = file_lock("networkmap");
	shm_client_info_id = shmget((key_t)shmkey, sizeof(CLIENT_DETAIL_INFO_TABLE), 0666 | IPC_CREAT);
	if (shm_client_info_id == -1)
	{
		fprintf(stderr, "shmget failed\n");
		file_unlock(lock);
		return 0;
	}

	shared_client_info = shmat(shm_client_info_id, (void *)0, 0);
	if (shared_client_info == (void *)-1)
	{
		fprintf(stderr, "shmat failed\n");
		file_unlock(lock);
		return 0;
	}

	NUM_2G = NUM_5G = 0;
	p_client_info_tab = (P_CLIENT_DETAIL_INFO_TABLE)shared_client_info;
	for (i = 0; i < p_client_info_tab->ip_mac_num; i++)
	{
		memset(dev_name, 0, sizeof(dev_name));
		memset(ipaddr, 0, sizeof(ipaddr));
		memset(mac_buf, 0, sizeof(mac_buf));
		memset(devname, 0, LINE_SIZE);
		memset(wireless, 0, sizeof(wireless));

		if (*p_client_info_tab->user_define[i])
			strlcpy(dev_name, (const char *)p_client_info_tab->user_define[i], sizeof(dev_name));
		else
			strlcpy(dev_name, (const char *)p_client_info_tab->device_name[i], sizeof(dev_name));

		if (p_client_info_tab->device_flag[i] & (1 << FLAG_EXIST))
		{
			len = strlen(dev_name);
			for (j = 0; (j < len) && (j < LINE_SIZE - 1); j++)
			{
				character = dev_name[j];
				if ((isalnum(character)) || (character == ' ') || (character == '-') || (character == '_') || (character == '(') || (character == ')'))
					devname[j] = character;
				else
					devname[j] = ' ';
			}

			sprintf(ipaddr, "%d.%d.%d.%d", p_client_info_tab->ip_addr[i][0], p_client_info_tab->ip_addr[i][1],
					p_client_info_tab->ip_addr[i][2], p_client_info_tab->ip_addr[i][3]);

			sprintf(mac_buf, "%02X:%02X:%02X:%02X:%02X:%02X",
					p_client_info_tab->mac_addr[i][0], p_client_info_tab->mac_addr[i][1],
					p_client_info_tab->mac_addr[i][2], p_client_info_tab->mac_addr[i][3],
					p_client_info_tab->mac_addr[i][4], p_client_info_tab->mac_addr[i][5]);

			sprintf(wireless, "%d", p_client_info_tab->wireless[i]);
			if (!strcmp(wireless, "1"))
				NUM_2G++;
			if (!strcmp(wireless, "2"))
				NUM_5G++;

			client = json_object_new_object();
			json_object_object_add(client, "name", json_object_new_string(devname));
			json_object_object_add(client, "nickName", json_object_new_string(""));
			json_object_object_add(client, "ip", json_object_new_string(ipaddr));
			json_object_object_add(client, "isWL", json_object_new_string(wireless));

			//Update attribute by custom_clientlist
			if (customList_status)
			{
				json_object_object_get_ex(customList, mac_buf, &custom_attr_get);
				if (custom_attr_get != NULL)
				{
					if (json_object_object_get_ex(custom_attr_get, "name", &custom_attr_get_name))
					{
						json_object_object_add(client, "nickName", json_object_new_string(json_object_get_string(custom_attr_get_name)));
					}
				}
			}

			json_object_object_add(clients, mac_buf, client);
		}
	}
	shmdt(shared_client_info);
	file_unlock(lock);

	if (customList)
		json_object_put(customList);
	if (custom_attr_get)
		json_object_put(custom_attr_get);

	return 1;
}

int get_traffic_data(char mac[18], char ip[15])
{
	FILE *pipo_stream = NULL;
	char buffer[4096];
	char cmd[128];
	signed int up_data = 0, dn_data = 0;
	if (swmode != 1) //not router mode
		return -1;
	if ((pipo_stream = popen("iptables --list", "r")) == NULL)
		return -1;

	fread(buffer, 1, sizeof(buffer), pipo_stream);
	pclose(pipo_stream);

	if (strstr(buffer, "UPSP") == NULL)
		doSystem("iptables -N UPSP");
	if (strstr(buffer, "DWSP") == NULL)
		doSystem("iptables -N DWSP");

	if (pipo_stream = popen("iptables -nvx -L FORWARD | grep UPSP", "r"))
	{
		fread(buffer, 1, sizeof(buffer), pipo_stream);
		pclose(pipo_stream);
		if (strstr(buffer, ip) == NULL)
		{
			doSystem("iptables -I FORWARD 1 -s %s -j UPSP", ip);
		}
	}
	if (pipo_stream = popen("iptables -nvx -L FORWARD | grep DWSP", "r"))
	{
		fread(buffer, 1, sizeof(buffer), pipo_stream);
		pclose(pipo_stream);
		if (strstr(buffer, ip) == NULL)
		{
			doSystem("iptables -I FORWARD 1 -d %s -j DWSP", ip);
		}
	}

	snprintf(cmd, sizeof(cmd), "iptables -nvx -L FORWARD | grep UPSP | grep %s -w  | awk '{print $2}'", ip);
	if (pipo_stream = popen(cmd, "r"))
	{
		fread(buffer, 1, sizeof(buffer), pipo_stream);
		pclose(pipo_stream);
		up_data = atoi((char *)&buffer);
	}
	snprintf(cmd, sizeof(cmd), "iptables -nvx -L FORWARD | grep DWSP | grep %s -w  | awk '{print $2}'", ip);
	if (pipo_stream = popen(cmd, "r"))
	{
		fread(buffer, 1, sizeof(buffer), pipo_stream);
		pclose(pipo_stream);
		dn_data = atoi((char *)&buffer);
	}

	AppendNode(mac, ip, up_data, dn_data, 0, 0);
	return 1;
}

// traffic monitor
int get_traffic_wan_data(unsigned long long *rx_data, unsigned long long *tx_data)
{
	FILE *fp;
	char buf[256];
	unsigned long long rx = 0, tx = 0, curr_rx = 0, curr_tx = 0;
	unsigned long long rx2 = 0, tx2 = 0;
	unsigned long long wired_all_rx = 0, wired_all_tx = 0;
	ino_t inode;
	struct ifino_s *ifino;
	static struct ifname_ino_tbl ifstat_tbl = {0};
	char *p;
	char *ifname;
	char ifname_desc[12], ifname_desc2[12];
	int wired_valid = 0;
	char *nv_lan_ifname;
	char *nv_lan_ifnames;

	nv_lan_ifname = nvram_safe_get("lan_ifname");
	nv_lan_ifnames = nvram_safe_get("lan_ifnames");

	fp = fopen("/proc/net/dev", "r");

	if (fp)
	{
		fgets(buf, sizeof(buf), fp);
		fgets(buf, sizeof(buf), fp);
		while (fgets(buf, sizeof(buf), fp))
		{
			if ((p = strchr(buf, ':')) == NULL)
				continue;
			*p = 0;
			if ((ifname = strrchr(buf, ' ')) == NULL)
				ifname = buf;
			else
				++ifname;
			if (sscanf(p + 1, "%llu%*u%*u%*u%*u%*u%*u%*u%llu", &rx, &tx) != 2)
				continue;
#ifdef RTCONFIG_BCM5301X_TRAFFIC_MONITOR
			/* WAN1, WAN2, LAN */
			if (strncmp(ifname, "vlan", 4) == 0)
			{
				traffic_wanlan(ifname, (uint32_t *)&rx, (uint32_t *)&tx);
			}
			if (nvram_match("wans_dualwan", "wan none"))
			{
				if (strcmp(ifname, "eth0") == 0)
				{
					traffic_wanlan(WAN0DEV, (uint32_t *)&rx, (uint32_t *)&tx);
				}
			}
#endif /* RTCONFIG_BCM5301X_TRAFFIC_MONITOR */
			if (!netdev_calc(ifname, ifname_desc, (unsigned long *)&rx, (unsigned long *)&tx,
							 ifname_desc2, (unsigned long *)&rx2, (unsigned long *)&tx2,
							 nv_lan_ifname, nv_lan_ifnames))
				continue;

			/* If inode of a interface changed, it means the interface was closed and reopened.
				 * In this case, we should calculate difference of old TX/RX bytes and new TX/RX
				 * bytes and shift from new TX/RX bytes to old TX/RX bytes.
				 */
			inode = get_iface_inode(ifname);
			curr_rx = rx;
			curr_tx = tx;
			if ((ifino = ifname_ino_ptr(&ifstat_tbl, ifname)) != NULL)
			{
				if (ifino->inode && ifino->inode != inode)
				{
					ifino->inode = inode;
					ifino->shift_rx = curr_rx - ifino->last_rx + ifino->shift_rx;
					ifino->shift_tx = curr_tx - ifino->last_tx + ifino->shift_tx;
				}
			}
			else
			{
				if ((ifstat_tbl.nr_items + 1) <= ARRAY_SIZE(ifstat_tbl.items))
				{
					ifino = &ifstat_tbl.items[ifstat_tbl.nr_items];
					strlcpy(ifino->ifname, ifname, sizeof(ifino->ifname));
					ifino->inode = inode;
					ifino->last_rx = curr_rx;
					ifino->last_tx = curr_tx;
					ifino->shift_rx = ifino->shift_tx = 0;
					ifstat_tbl.nr_items++;
				}
			}

			if (ifino != NULL)
			{
				rx = curr_rx - ifino->shift_rx;
				tx = curr_tx - ifino->shift_tx;
				ifino->last_rx = curr_rx;
				ifino->last_tx = curr_tx;
			}

		loopagain:
			if (!strncmp(ifname_desc, "WIRED", 5))
			{
				wired_valid = 1;
				wired_all_rx += rx;
				wired_all_tx += tx;
			}
			if (strlen(ifname_desc2))
			{
				strcpy(ifname_desc, ifname_desc2);
				rx = rx2;
				tx = tx2;
				strcpy(ifname_desc2, "");
				goto loopagain;
			}
		}
		if (wired_valid)
		{
			*rx_data = wired_all_rx;
			*tx_data = wired_all_tx;
		}
		fclose(fp);
	}
	return 0;
}

int find_logo(char mac[])
{
	char curmac[7] = {0};
	int i, j = 0, k = 0;
	int length = sizeof(logo) / sizeof(logo[0]);
	if (strlen(mac) <= 0)
		return 0;
	while (k < 6)
	{
		if (mac[j] != ':')
		{
			curmac[k++] = toupper(mac[j]);
		}
		j++;
	}
	for (i = 0; i < length; i++)
	{
		if (strstr(logo[i], curmac))
			return i;
	}
	return 0;
}

void fputheader(FILE *fp)
{
	fputs("#!/bin/sh\n", fp);
}

int output_basic_sh()
{
	char *MAC_ADDR = nvram_get("et2macaddr");
	char *BUILD_NO = nvram_get("buildno");
	char *EXTEND_NO = nvram_get("extendno");
	FILE *fp = NULL;
	char HW_VERSION[21];
	char FW_VERSION[64], NEW_FW_VERSION[64];

	snprintf(FW_VERSION, sizeof(FW_VERSION), "%s_%s", BUILD_NO, EXTEND_NO);
	snprintf(NEW_FW_VERSION, sizeof(NEW_FW_VERSION), "%s", nvram_get("new_fw_version"));

	if (swmode == 1)
	{
		snprintf(HW_VERSION, sizeof(HW_VERSION), "A1/A2");
	}
	else
	{
		snprintf(HW_VERSION, sizeof(HW_VERSION), "AP:%s", nvram_get("lan_ipaddr"));
	}

	if (fp = fopen("/tmp/k3screenctrl/basic.sh", "w+"))
	{
		fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
	}
	else
	{
		_dprintf("k3screenbg: can't open basic.sh\n");
		return -1;
	}

	fputheader(fp);							  //1. #sh script header
	fputs("echo K3\n", fp);					  //2. MODEL
	fprintf(fp, "echo %s\n", HW_VERSION);	  //3. HW version
	fprintf(fp, "echo %s\n", FW_VERSION);	  //4. FW version
	fprintf(fp, "echo %s\n", NEW_FW_VERSION); //5. New FW version
	fprintf(fp, "echo %s\n", MAC_ADDR);		  //6. MAC address
	fclose(fp);
	fp = NULL;
	return 1;
}

int output_wan_sh()
{
	char IPV4_ADDR[16];
	int FLAG = nvram_get_int("ure_disable");
	int CONNECTED = 0, UPLOAD_BPS = 0, DOWNLOAD_BPS = 0, MODE = 0;
	FILE *fp = NULL;
	unsigned long long now_upload_wan = 0, now_dnload_wan = 0;

	bzero(IPV4_ADDR, sizeof(IPV4_ADDR));
	MODE = (swmode == 1 ? 0 : 1);
	if (nvram_get_int("link_internet") == 2)
	{
		CONNECTED = 1;
	}

	if (strcmp(nvram_get("wan0_ipaddr"), "0.0.0.0"))
	{
		strlcpy(IPV4_ADDR, nvram_get("wan0_ipaddr"), sizeof(IPV4_ADDR));
	}
	else if (strcmp(nvram_get("wan1_ipaddr"), "0.0.0.0"))
	{
		strlcpy(IPV4_ADDR, nvram_get("wan1_ipaddr"), sizeof(IPV4_ADDR));
	}

	get_traffic_wan_data(&now_upload_wan, &now_dnload_wan);
	UPLOAD_BPS = (now_upload_wan - last_upload_wan) / DEFAULT_UPDATE_INTERVAL;
	DOWNLOAD_BPS = (now_dnload_wan - last_dnload_wan) / DEFAULT_UPDATE_INTERVAL;
	last_upload_wan = now_upload_wan;
	last_dnload_wan = now_dnload_wan;

RET:
	if (fp = fopen("/tmp/k3screenctrl/wan.sh", "w+"))
	{
		fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
	}
	else
	{
		_dprintf("k3screenbg: can't open wan.sh\n");
		return -1;
	}

	fputheader(fp);							//1. #sh script header
	fprintf(fp, "echo %d\n", CONNECTED);	//2. Internet connected?
	fprintf(fp, "echo %s\n", IPV4_ADDR);	//3. IPV4 address
	fprintf(fp, "echo %d\n", UPLOAD_BPS);	//4. Upload speed
	fprintf(fp, "echo %d\n", DOWNLOAD_BPS); //5. Download speed
	fprintf(fp, "echo %d\n", FLAG);			//6. flag
	fprintf(fp, "echo %d\n", MODE);			//7. mode
	fclose(fp);
	fp = NULL;
	return 1;
}

int output_wifi_sh()
{
	int SMART_CONNECT = nvram_get_int("smart_connect_x");

	char *SSID_2G = nvram_get("wl0_ssid");
	char *PWD_2G = NULL;
	char *AUTH_MODE_2G = nvram_get("wl0_auth_mode_x");
	int ENABLED_2G = nvram_get_int("wl0_bss_enabled");

	char *SSID_5G = nvram_get("wl1_ssid");
	char *PWD_5G = NULL;
	char *AUTH_MODE_5G = nvram_get("wl1_auth_mode_x");
	int ENABLED_5G = nvram_get_int("wl1_bss_enabled");

	int ENABLED_VISITOR = 0;
	char SSID_GUEST[32], PWD_GUEST[64];
	int NUM_GUEST = 0;
	int HIDEPWD = nvram_get_int("screen_hidepwd");
	int HIDEPWD_VISITOR = nvram_get_int("screen_hidepwd_visitor");

	FILE *fp = NULL;

	if (!strcmp(AUTH_MODE_2G, "open"))
	{
		PWD_2G = "";
	}
	else if (HIDEPWD == 1)
	{
		PWD_2G = "********";
	}
	else
	{
		PWD_2G = nvram_get("wl0_wpa_psk");
	}

	if (!strcmp(AUTH_MODE_5G, "open"))
	{
		PWD_5G = "";
	}
	else if (HIDEPWD == 1)
	{
		PWD_5G = "********";
	}
	else
	{
		PWD_5G = nvram_get("wl1_wpa_psk");
	}

	int guest_2g[3] = {0}, guest_5g[3] = {0};
	int i;
	char tmp[18];
	bzero(tmp, sizeof(tmp));
	for (i = 1; i <= 3; i++)
	{
		snprintf(tmp, sizeof(tmp), "wl0.%d_bss_enabled", i);
		guest_2g[i] = nvram_get_int(tmp);
		snprintf(tmp, sizeof(tmp), "wl1.%d_bss_enabled", i);
		guest_5g[i] = nvram_get_int(tmp);
		if (guest_2g[i] || guest_5g[i])
			ENABLED_VISITOR = 1;
	}

	bzero(SSID_GUEST, sizeof(SSID_GUEST));
	bzero(PWD_GUEST, sizeof(PWD_GUEST));
	if (ENABLED_VISITOR)
	{
		for (i = 1; i <= 3; i++)
		{
			if (guest_2g[i])
			{
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl0.%d_ssid", i);
				strlcpy(SSID_GUEST, nvram_get(tmp), sizeof(SSID_GUEST));
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl0.%d_wpa_psk", i);
				strlcpy(PWD_GUEST, nvram_get(tmp), sizeof(PWD_GUEST));
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl0.%d_auth_mode_x", i);
				break;
			}
			if (guest_5g[i])
			{
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl1.%d_ssid", i);
				strlcpy(SSID_GUEST, nvram_get(tmp), sizeof(SSID_GUEST));
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl1.%d_wpa_psk", i);
				strlcpy(PWD_GUEST, nvram_get(tmp), sizeof(PWD_GUEST));
				bzero(tmp, sizeof(tmp));
				snprintf(tmp, sizeof(tmp), "wl1.%d_auth_mode_x", i);
				break;
			}
		}
		if (!strcmp(tmp, "open"))
		{
			bzero(PWD_GUEST, sizeof(PWD_GUEST));
		}
		else if (HIDEPWD_VISITOR == 1)
		{
			strlcpy(PWD_GUEST, "********", sizeof(PWD_GUEST));
		}
	}

	if (fp = fopen("/tmp/k3screenctrl/wifi.sh", "w+"))
	{
		fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
	}
	else
	{
		_dprintf("k3screenbg: can't open wifi.sh\n");
		return -1;
	}

	fputheader(fp);							   //1. #sh script header
	fprintf(fp, "echo %d\n", SMART_CONNECT);   //2. Band steering?
	fprintf(fp, "echo '%s'\n", SSID_2G);	   //3. 2.4GHz SSID
	fprintf(fp, "echo '%s'\n", PWD_2G);		   //4. 2.4GHz password
	fprintf(fp, "echo %d\n", ENABLED_2G);	   //5. 2.4GHz enabled
	fprintf(fp, "echo %d\n", NUM_2G);		   //6. Number of clients connected to 2.4GHz
	fprintf(fp, "echo '%s'\n", SSID_5G);	   //7. 5GHz SSID
	fprintf(fp, "echo '%s'\n", PWD_5G);		   //8. 5GHz password
	fprintf(fp, "echo %d\n", ENABLED_5G);	   //9. 5GHz enabled
	fprintf(fp, "echo %d\n", NUM_5G);		   //10. Number of clients connected to 5GHz
	fprintf(fp, "echo '%s'\n", SSID_GUEST);	   //11. Visitor network SSID
	fprintf(fp, "echo '%s'\n", PWD_GUEST);	   //12. Visitor network password
	fprintf(fp, "echo %d\n", ENABLED_VISITOR); //13. Visitor network enabled
	fprintf(fp, "echo %d\n", NUM_GUEST);	   //14. Number of clients connected to visitor network
	fclose(fp);
	fp = NULL;
	return 1;
}

int output_host_sh()
{
	struct json_object *clients = NULL;

	char name[32], nickname[32], ip[15], mac[18];
	char hostname[32];
	NODE *pNode = NULL;
	signed int now_upload = 0, now_dnload = 0;
	signed int last_upload = 0, last_dnload = 0;
	signed int spd_upload = 0, spd_dnload = 0;
	int brand = 0;
	FILE *fp = NULL;

	if ((nvram_match("refresh_networkmap", "1") || nvram_match("rescan_networkmap", "1")) && (check_if_file_exist(NMP_CACHE_FILE)))
	{
		clients = json_object_from_file(NMP_CACHE_FILE);
	}
	else if (pids("networkmap"))
	{
		clients = json_object_new_object();
		get_client_detail_info(clients, SHMKEY_LAN);
	}
	if (clients == NULL)
		return -2;

	if (fp = fopen("/tmp/k3screenctrl/host.sh", "w+"))
	{
		fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
	}
	else
	{
		_dprintf("k3screenbg: can't open host.sh\n");
		return -1;
	}

	struct json_object *obj_name = NULL, *obj_nickname = NULL, *obj_ip = NULL;
	int hosts_num = json_object_object_length(clients);
	fputheader(fp);						 //1. #sh script header
	fprintf(fp, "echo %d\n", hosts_num); //2. Number of hosts

	json_object_object_foreach(clients, json_key, json_client)
	{
		strlcpy(mac, json_key, sizeof(mac));
		bzero(name, sizeof(name));
		bzero(nickname, sizeof(nickname));
		bzero(ip, sizeof(ip));
		if (json_object_object_get_ex(json_client, "name", &obj_name))
		{
			strlcpy(name, json_object_get_string(obj_name), sizeof(name));
		}
		if (json_object_object_get_ex(json_client, "nickName", &obj_nickname))
		{
			strlcpy(nickname, json_object_get_string(obj_nickname), sizeof(name));
		}
		if (json_object_object_get_ex(json_client, "ip", &obj_ip))
		{
			strlcpy(ip, json_object_get_string(obj_ip), sizeof(name));
		}
		get_traffic_data(mac, ip);
		if (pNode = FindNode(mac))
		{
			now_upload = pNode->up_data;
			now_dnload = pNode->dn_data;
			last_upload = pNode->last_up_data;
			last_dnload = pNode->last_dn_data;
			AppendNode(mac, NULL, 0, 0, now_upload, now_dnload);
		}
		spd_upload = (now_upload - last_upload) / DEFAULT_UPDATE_INTERVAL;
		spd_dnload = (now_dnload - last_dnload) / DEFAULT_UPDATE_INTERVAL;

		brand = find_logo(mac);

		if (strlen(nickname) > 0)
		{
			strlcpy(hostname, nickname, sizeof(hostname));
		}
		else if (strcmp(name, "*") == 0 || strcmp(name, "?") == 0 || strlen(name) == 0)
		{
			strlcpy(hostname, mac, sizeof(hostname));
		}
		else
		{
			strlcpy(hostname, name, sizeof(hostname));
		}

		fprintf(fp, "echo %s\n", hostname);		//3. Host name
		fprintf(fp, "echo %d\n", spd_dnload);	//4. Host download speed
		fprintf(fp, "echo %d\n", spd_upload);	//5. Host upload speed
		fprintf(fp, "echo %d\n", brand);		//6. Host brand
	}
	fclose(fp);
	fp = NULL;

	if (clients)
		json_object_put(clients);
	return 1;
}

int output_weather_sh()
{
	time_t tmpcal_ptr = 0;
	struct tm *tmp_ptr = NULL;
	char ch_date[11], ch_time[6];
	int week = 0;
	time(&tmpcal_ptr);
	tmp_ptr = localtime(&tmpcal_ptr);
	snprintf(ch_date, sizeof(ch_date), "%d-%d-%d", (1900 + tmp_ptr->tm_year), (1 + tmp_ptr->tm_mon), tmp_ptr->tm_mday);
	snprintf(ch_time, sizeof(ch_time), "%02d:%02d", tmp_ptr->tm_hour, tmp_ptr->tm_min);
	week = tmp_ptr->tm_wday;

	char url[128];
	char url1[] = "https://api.seniverse.com/v3/weather/now.json";
	char url2[] = "language=zh-Hans&unit=c";
	const char *localfile = "/tmp/weather.json";
	char *weather_key = nvram_get("weather_key");
	char *weather_city = nvram_get("weather_city");
	char ch_city[64] = {0}, ch_temp[3] = {0}, ch_code[3] = {0};
	time_t now_time = 0;
	long timer = 0;
	FILE *fp = NULL;
	int ret = 0;

	int interval = nvram_get_int("weather_interval");
	if (interval <= 0)
		goto GETERR;

	curl_global_init(CURL_GLOBAL_ALL);
	CURL *curlhandle = curl_easy_init();

	snprintf(url, sizeof(url), "%s?key=%s&location=%s&%s", url1, weather_key, strlen(weather_city) ? weather_city : "ip", url2);

	timer = MAX(interval, REFRESH_INTERVAL_MIN);
	time(&now_time);
	if (last_time == 0 || now_time - last_time >= timer || !check_if_file_exist(localfile))
	{
		if (check_if_file_exist(localfile))
			unlink(localfile);
		if (curl_download_file(curlhandle, url, localfile, 10, 3) != 1)
		{
			last_time = 0;
			goto GETERR;
		}
		last_time = now_time;
	}

	struct json_object *json_obj = json_object_from_file(localfile);
	get_json_value(json_obj, "name", ch_city);
	get_json_value(json_obj, "temperature", ch_temp);
	get_json_value(json_obj, "code", ch_code);
	json_object_put(json_obj);
	ret = 1;

GETERR:
	if (fp = fopen("/tmp/k3screenctrl/weather.sh", "w+"))
	{
		fchmod(fileno(fp), S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
	}
	else
	{
		_dprintf("k3screenbg: can't open weather.sh\n");
		return -1;
	}

	fputheader(fp);									  //1. #sh script header
	fprintf(fp, "echo %s\n", ch_city ? ch_city : ""); //2. city
	fprintf(fp, "echo %s\n", ch_temp ? ch_temp : ""); //3. temp
	fprintf(fp, "echo %s\n", ch_date);				  //4. date
	fprintf(fp, "echo %s\n", ch_time);				  //5. time
	fprintf(fp, "echo %s\n", ch_code ? ch_code : ""); //6. weather
	fprintf(fp, "echo %d\n", week);					  //7. week
	fprintf(fp, "echo %d\n", ret == 1 ? 0 : 1);		  //8. error
	fclose(fp);

	curl_easy_cleanup(curlhandle);
	curl_global_cleanup();
	return ret;
}

void sig_handler(int signal_num)
{
	swmode = nvram_get_int("sw_mode"); //1=router,2=ap,3=rp or aimesh,4=wb

	//output_basic_sh();
	output_wan_sh();
	output_wifi_sh();
	output_host_sh();
	output_weather_sh();
}

void clean(int signal_num)
{
	FreeNodeList();
}

int main(int argc, char *argv[])
{
	signal(SIGALRM, sig_handler);
	signal(SIGTERM, clean);
	while (1)
	{
		alarm(DEFAULT_UPDATE_INTERVAL);
		pause();
	}
}
